/**
 * TONAIAgent - Anti-Exploit Mechanisms
 *
 * Provides sybil resistance, rate limiting, emission controls,
 * and slashing mechanisms to prevent gaming and exploitation.
 */

import {
  AntiExploitConfig,
  SybilCheckResult,
  SybilRiskFactor,
  ClaimValidationRequest,
  ClaimValidationResult,
  TokenomicsRateLimitConfig,
  RateLimitCheckResult,
  EmissionStatus,
  SlashRequest,
  SlashResult,
  SlashEvent,
  TokenomicsEvent,
  TokenomicsEventCallback,
} from './types';

// ============================================================================
// Default Configuration
// ============================================================================

const DEFAULT_ANTI_EXPLOIT_CONFIG: AntiExploitConfig = {
  sybilDetectionEnabled: true,
  rateLimitingEnabled: true,
  emissionControlEnabled: true,
  slashingEnabled: true,
  rewardCaps: {
    daily: '1000000000000', // 1000 tokens
    weekly: '5000000000000', // 5000 tokens
    monthly: '15000000000000', // 15000 tokens
  },
  minAccountAge: 7, // days
  minStakeRequired: '100000000000', // 100 tokens
  behaviorAnalysis: true,
};

const DEFAULT_RATE_LIMITS: TokenomicsRateLimitConfig = {
  operations: {
    stake: { maxPerHour: 5, maxPerDay: 20 },
    unstake: { maxPerHour: 3, maxPerDay: 10 },
    claim: { maxPerHour: 10, maxPerDay: 50 },
    vote: { maxPerProposal: 1, maxPerDay: 20 },
    delegate: { maxPerHour: 2, maxPerDay: 5 },
    transfer: { maxPerHour: 20, maxPerDay: 100 },
    trade: { maxPerHour: 50, maxPerDay: 500 },
  },
  cooldowns: {
    afterUnstake: 86400, // 24 hours
    afterSlash: 604800, // 7 days
    afterVote: 60, // 1 minute
    afterClaim: 3600, // 1 hour
  },
};

// Sybil risk factors and weights
const SYBIL_RISK_WEIGHTS: Record<string, number> = {
  new_account: 0.3,
  low_activity: 0.2,
  similar_behavior: 0.25,
  low_stake: 0.15,
  suspicious_timing: 0.1,
};

// ============================================================================
// Interfaces
// ============================================================================

export interface AntiExploitManager {
  readonly config: AntiExploitConfig;

  // Sybil detection
  checkSybil(userId: string): Promise<SybilCheckResult>;
  registerAccount(userId: string, metadata: AccountMetadata): Promise<void>;
  reportSybil(userId: string, reporterId: string, evidence: string[]): Promise<void>;

  // Rate limiting
  checkRateLimit(userId: string, operation: string): Promise<RateLimitCheckResult>;
  recordOperation(userId: string, operation: string): Promise<void>;
  getCooldownStatus(userId: string, operation: string): Promise<CooldownStatus>;

  // Reward caps
  validateClaim(request: ClaimValidationRequest): Promise<ClaimValidationResult>;
  getClaimStatus(userId: string): Promise<ClaimStatus>;

  // Emission control
  getEmissionStatus(): Promise<EmissionStatus>;
  recordEmission(amount: string): Promise<void>;
  canEmit(amount: string): Promise<boolean>;

  // Slashing
  executeSlash(request: SlashRequest): Promise<SlashResult>;
  appealSlash(slashId: string, evidence: string[]): Promise<AppealResult>;
  getSlashHistory(targetId: string): Promise<SlashEvent[]>;

  // Events
  onEvent(callback: TokenomicsEventCallback): void;
}

export interface AccountMetadata {
  createdAt: Date;
  telegramId?: string;
  walletAddress?: string;
  referrer?: string;
  ipAddress?: string;
  deviceId?: string;
}

export interface CooldownStatus {
  active: boolean;
  endsAt?: Date;
  remainingSeconds?: number;
  reason?: string;
}

export interface ClaimStatus {
  dailyClaimed: string;
  weeklyClaimed: string;
  monthlyClaimed: string;
  dailyRemaining: string;
  weeklyRemaining: string;
  monthlyRemaining: string;
  lastClaimTime?: Date;
  nextClaimAvailable?: Date;
}

export interface AppealResult {
  success: boolean;
  slashId: string;
  status: 'pending' | 'approved' | 'rejected';
  reason?: string;
}

// ============================================================================
// Implementation
// ============================================================================

export class DefaultAntiExploitManager implements AntiExploitManager {
  readonly config: AntiExploitConfig;
  private readonly rateLimits: TokenomicsRateLimitConfig;

  // Storage
  private readonly accountMetadata: Map<string, AccountMetadata> = new Map();
  private readonly operationHistory: Map<string, Map<string, Date[]>> = new Map(); // userId -> operation -> timestamps
  private readonly cooldowns: Map<string, Map<string, Date>> = new Map(); // userId -> operation -> endTime
  private readonly claimHistory: Map<string, ClaimRecord[]> = new Map();
  private readonly slashHistory: Map<string, SlashEvent[]> = new Map();
  private readonly sybilReports: Map<string, SybilReport[]> = new Map();

  // Emission tracking
  private emissionStatus: EmissionStatus = {
    dailyEmitted: '0',
    dailyCap: '1000000000000000', // 1M tokens
    dailyRemaining: '1000000000000000',
    weeklyEmitted: '0',
    weeklyCap: '5000000000000000', // 5M tokens
    weeklyRemaining: '5000000000000000',
    monthlyEmitted: '0',
    monthlyCap: '15000000000000000', // 15M tokens
    monthlyRemaining: '15000000000000000',
    totalEmitted: '0',
    inflationRate: 0,
  };

  private readonly eventCallbacks: TokenomicsEventCallback[] = [];

  constructor(config: Partial<AntiExploitConfig> = {}, rateLimits: Partial<TokenomicsRateLimitConfig> = {}) {
    this.config = { ...DEFAULT_ANTI_EXPLOIT_CONFIG, ...config };
    this.rateLimits = {
      operations: { ...DEFAULT_RATE_LIMITS.operations, ...rateLimits.operations },
      cooldowns: { ...DEFAULT_RATE_LIMITS.cooldowns, ...rateLimits.cooldowns },
    };
  }

  // --------------------------------------------------------------------------
  // Sybil Detection
  // --------------------------------------------------------------------------

  async checkSybil(userId: string): Promise<SybilCheckResult> {
    if (!this.config.sybilDetectionEnabled) {
      return {
        userId,
        isSuspicious: false,
        riskScore: 0,
        riskFactors: [],
        recommendation: 'allow',
        details: {},
      };
    }

    const metadata = this.accountMetadata.get(userId);
    const riskFactors: SybilRiskFactor[] = [];
    let totalRiskScore = 0;

    // Check account age
    if (metadata) {
      const accountAgeDays = (Date.now() - metadata.createdAt.getTime()) / (24 * 60 * 60 * 1000);
      if (accountAgeDays < this.config.minAccountAge) {
        const factor: SybilRiskFactor = {
          factor: 'new_account',
          weight: SYBIL_RISK_WEIGHTS.new_account,
          score: Math.min(1, (this.config.minAccountAge - accountAgeDays) / this.config.minAccountAge),
          description: `Account is ${Math.floor(accountAgeDays)} days old (minimum: ${this.config.minAccountAge})`,
        };
        riskFactors.push(factor);
        totalRiskScore += factor.weight * factor.score;
      }
    } else {
      // No metadata means very new account
      riskFactors.push({
        factor: 'new_account',
        weight: SYBIL_RISK_WEIGHTS.new_account,
        score: 1,
        description: 'No account metadata found',
      });
      totalRiskScore += SYBIL_RISK_WEIGHTS.new_account;
    }

    // Check activity level
    const operations = this.operationHistory.get(userId);
    if (!operations || operations.size === 0) {
      riskFactors.push({
        factor: 'low_activity',
        weight: SYBIL_RISK_WEIGHTS.low_activity,
        score: 1,
        description: 'No activity history',
      });
      totalRiskScore += SYBIL_RISK_WEIGHTS.low_activity;
    }

    // Check for similar behavior patterns (simplified)
    if (this.config.behaviorAnalysis) {
      const similarityScore = this.checkBehaviorSimilarity(userId);
      if (similarityScore > 0.7) {
        riskFactors.push({
          factor: 'similar_behavior',
          weight: SYBIL_RISK_WEIGHTS.similar_behavior,
          score: similarityScore,
          description: 'Behavior pattern similar to other accounts',
        });
        totalRiskScore += SYBIL_RISK_WEIGHTS.similar_behavior * similarityScore;
      }
    }

    // Check sybil reports
    const reports = this.sybilReports.get(userId) ?? [];
    if (reports.length > 0) {
      const reportScore = Math.min(1, reports.length / 3);
      riskFactors.push({
        factor: 'reported_sybil',
        weight: 0.5,
        score: reportScore,
        description: `${reports.length} sybil report(s) filed`,
      });
      totalRiskScore += 0.5 * reportScore;
    }

    // Normalize risk score to 0-100
    const normalizedScore = Math.min(100, totalRiskScore * 100);

    // Determine recommendation
    let recommendation: 'allow' | 'review' | 'block' = 'allow';
    if (normalizedScore >= 70) {
      recommendation = 'block';
    } else if (normalizedScore >= 40) {
      recommendation = 'review';
    }

    const result: SybilCheckResult = {
      userId,
      isSuspicious: normalizedScore >= 40,
      riskScore: normalizedScore,
      riskFactors,
      recommendation,
      details: {
        accountAge: metadata ? (Date.now() - metadata.createdAt.getTime()) / (24 * 60 * 60 * 1000) : 0,
        operationCount: operations?.size ?? 0,
        reportCount: reports.length,
      },
    };

    // Emit event if suspicious
    if (result.isSuspicious) {
      this.emitEvent({
        type: 'sybil_detected',
        category: 'anti_exploit',
        data: {
          userId,
          riskScore: normalizedScore,
          recommendation,
        },
        userId,
      });
    }

    return result;
  }

  private checkBehaviorSimilarity(_userId: string): number {
    // Simplified behavior similarity check
    // In production, this would use ML clustering and time-series analysis
    return 0;
  }

  async registerAccount(userId: string, metadata: AccountMetadata): Promise<void> {
    this.accountMetadata.set(userId, metadata);
  }

  async reportSybil(userId: string, reporterId: string, evidence: string[]): Promise<void> {
    if (!this.sybilReports.has(userId)) {
      this.sybilReports.set(userId, []);
    }

    this.sybilReports.get(userId)!.push({
      reporterId,
      evidence,
      timestamp: new Date(),
    });
  }

  // --------------------------------------------------------------------------
  // Rate Limiting
  // --------------------------------------------------------------------------

  async checkRateLimit(userId: string, operation: string): Promise<RateLimitCheckResult> {
    if (!this.config.rateLimitingEnabled) {
      return {
        allowed: true,
        remaining: Infinity,
        resetsAt: new Date(),
        cooldownActive: false,
      };
    }

    // Check cooldown first
    const cooldown = await this.getCooldownStatus(userId, operation);
    if (cooldown.active) {
      return {
        allowed: false,
        remaining: 0,
        resetsAt: cooldown.endsAt!,
        cooldownActive: true,
        cooldownEndsAt: cooldown.endsAt,
      };
    }

    // Get operation limits
    const limits = this.rateLimits.operations[operation];
    if (!limits) {
      // No limits defined for this operation
      return {
        allowed: true,
        remaining: Infinity,
        resetsAt: new Date(),
        cooldownActive: false,
      };
    }

    // Get operation history
    const userOps = this.operationHistory.get(userId);
    const opHistory = userOps?.get(operation) ?? [];

    // Filter to recent operations
    const now = new Date();
    const hourAgo = new Date(now.getTime() - 60 * 60 * 1000);
    const dayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);

    const lastHour = opHistory.filter(d => d > hourAgo).length;
    const lastDay = opHistory.filter(d => d > dayAgo).length;

    // Check limits
    let allowed = true;
    let remaining = Infinity;
    let resetsAt = now;

    if (limits.maxPerHour && lastHour >= limits.maxPerHour) {
      allowed = false;
      remaining = 0;
      resetsAt = new Date(hourAgo.getTime() + 60 * 60 * 1000);
    } else if (limits.maxPerHour) {
      remaining = Math.min(remaining, limits.maxPerHour - lastHour);
      resetsAt = new Date(now.getTime() + 60 * 60 * 1000);
    }

    if (limits.maxPerDay && lastDay >= limits.maxPerDay) {
      allowed = false;
      remaining = 0;
      resetsAt = new Date(dayAgo.getTime() + 24 * 60 * 60 * 1000);
    } else if (limits.maxPerDay) {
      remaining = Math.min(remaining, limits.maxPerDay - lastDay);
    }

    if (!allowed) {
      this.emitEvent({
        type: 'rate_limit_exceeded',
        category: 'anti_exploit',
        data: {
          userId,
          operation,
          lastHour,
          lastDay,
        },
        userId,
      });
    }

    return {
      allowed,
      remaining: Math.max(0, remaining),
      resetsAt,
      cooldownActive: false,
    };
  }

  async recordOperation(userId: string, operation: string): Promise<void> {
    if (!this.operationHistory.has(userId)) {
      this.operationHistory.set(userId, new Map());
    }

    const userOps = this.operationHistory.get(userId)!;
    if (!userOps.has(operation)) {
      userOps.set(operation, []);
    }

    userOps.get(operation)!.push(new Date());

    // Cleanup old entries (keep last 24 hours)
    const cutoff = new Date(Date.now() - 24 * 60 * 60 * 1000);
    const filtered = userOps.get(operation)!.filter(d => d > cutoff);
    userOps.set(operation, filtered);
  }

  async getCooldownStatus(userId: string, operation: string): Promise<CooldownStatus> {
    const userCooldowns = this.cooldowns.get(userId);
    if (!userCooldowns) {
      return { active: false };
    }

    const cooldownEnd = userCooldowns.get(operation);
    if (!cooldownEnd) {
      return { active: false };
    }

    const now = new Date();
    if (now >= cooldownEnd) {
      // Cooldown expired, remove it
      userCooldowns.delete(operation);
      return { active: false };
    }

    return {
      active: true,
      endsAt: cooldownEnd,
      remainingSeconds: Math.ceil((cooldownEnd.getTime() - now.getTime()) / 1000),
      reason: `Cooldown after ${operation}`,
    };
  }

  /**
   * Set cooldown for a user/operation (internal use)
   */
  setCooldown(userId: string, operation: string, durationSeconds?: number): void {
    if (!this.cooldowns.has(userId)) {
      this.cooldowns.set(userId, new Map());
    }

    const duration = durationSeconds ?? this.rateLimits.cooldowns[`after${operation.charAt(0).toUpperCase()}${operation.slice(1)}`] ?? 60;
    const endsAt = new Date(Date.now() + duration * 1000);

    this.cooldowns.get(userId)!.set(operation, endsAt);
  }

  // --------------------------------------------------------------------------
  // Reward Caps
  // --------------------------------------------------------------------------

  async validateClaim(request: ClaimValidationRequest): Promise<ClaimValidationResult> {
    const status = await this.getClaimStatus(request.userId);
    const amount = BigInt(request.amount);

    // Check daily cap
    if (amount > BigInt(status.dailyRemaining)) {
      return {
        allowed: false,
        reason: 'Daily reward cap exceeded',
        dailyRemaining: status.dailyRemaining,
        weeklyRemaining: status.weeklyRemaining,
        monthlyRemaining: status.monthlyRemaining,
      };
    }

    // Check weekly cap
    if (amount > BigInt(status.weeklyRemaining)) {
      return {
        allowed: false,
        reason: 'Weekly reward cap exceeded',
        dailyRemaining: status.dailyRemaining,
        weeklyRemaining: status.weeklyRemaining,
        monthlyRemaining: status.monthlyRemaining,
      };
    }

    // Check monthly cap
    if (amount > BigInt(status.monthlyRemaining)) {
      return {
        allowed: false,
        reason: 'Monthly reward cap exceeded',
        dailyRemaining: status.dailyRemaining,
        weeklyRemaining: status.weeklyRemaining,
        monthlyRemaining: status.monthlyRemaining,
      };
    }

    // Check cooldown
    const cooldown = await this.getCooldownStatus(request.userId, 'claim');
    if (cooldown.active) {
      return {
        allowed: false,
        reason: 'Claim cooldown active',
        cooldownRemaining: cooldown.remainingSeconds,
        dailyRemaining: status.dailyRemaining,
        weeklyRemaining: status.weeklyRemaining,
        monthlyRemaining: status.monthlyRemaining,
      };
    }

    return {
      allowed: true,
      dailyRemaining: (BigInt(status.dailyRemaining) - amount).toString(),
      weeklyRemaining: (BigInt(status.weeklyRemaining) - amount).toString(),
      monthlyRemaining: (BigInt(status.monthlyRemaining) - amount).toString(),
    };
  }

  async getClaimStatus(userId: string): Promise<ClaimStatus> {
    const history = this.claimHistory.get(userId) ?? [];
    const now = new Date();

    // Calculate time windows
    const dayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    // Sum claims in each window
    let dailyClaimed = BigInt(0);
    let weeklyClaimed = BigInt(0);
    let monthlyClaimed = BigInt(0);
    let lastClaimTime: Date | undefined;

    for (const claim of history) {
      const amount = BigInt(claim.amount);
      if (claim.timestamp > dayAgo) dailyClaimed += amount;
      if (claim.timestamp > weekAgo) weeklyClaimed += amount;
      if (claim.timestamp > monthAgo) monthlyClaimed += amount;

      if (!lastClaimTime || claim.timestamp > lastClaimTime) {
        lastClaimTime = claim.timestamp;
      }
    }

    // Calculate remaining
    const dailyRemaining = BigInt(this.config.rewardCaps.daily) - dailyClaimed;
    const weeklyRemaining = BigInt(this.config.rewardCaps.weekly) - weeklyClaimed;
    const monthlyRemaining = BigInt(this.config.rewardCaps.monthly) - monthlyClaimed;

    // Calculate next claim available
    let nextClaimAvailable: Date | undefined;
    if (lastClaimTime) {
      const cooldown = this.rateLimits.cooldowns.afterClaim ?? 3600;
      nextClaimAvailable = new Date(lastClaimTime.getTime() + cooldown * 1000);
      if (nextClaimAvailable < now) {
        nextClaimAvailable = undefined;
      }
    }

    return {
      dailyClaimed: dailyClaimed.toString(),
      weeklyClaimed: weeklyClaimed.toString(),
      monthlyClaimed: monthlyClaimed.toString(),
      dailyRemaining: dailyRemaining.toString(),
      weeklyRemaining: weeklyRemaining.toString(),
      monthlyRemaining: monthlyRemaining.toString(),
      lastClaimTime,
      nextClaimAvailable,
    };
  }

  /**
   * Record a claim (internal use)
   */
  recordClaim(userId: string, amount: string): void {
    if (!this.claimHistory.has(userId)) {
      this.claimHistory.set(userId, []);
    }

    this.claimHistory.get(userId)!.push({
      amount,
      timestamp: new Date(),
    });

    // Set cooldown
    this.setCooldown(userId, 'claim', this.rateLimits.cooldowns.afterClaim);
  }

  // --------------------------------------------------------------------------
  // Emission Control
  // --------------------------------------------------------------------------

  async getEmissionStatus(): Promise<EmissionStatus> {
    // Update remaining amounts
    this.emissionStatus.dailyRemaining = (
      BigInt(this.emissionStatus.dailyCap) - BigInt(this.emissionStatus.dailyEmitted)
    ).toString();
    this.emissionStatus.weeklyRemaining = (
      BigInt(this.emissionStatus.weeklyCap) - BigInt(this.emissionStatus.weeklyEmitted)
    ).toString();
    this.emissionStatus.monthlyRemaining = (
      BigInt(this.emissionStatus.monthlyCap) - BigInt(this.emissionStatus.monthlyEmitted)
    ).toString();

    return { ...this.emissionStatus };
  }

  async recordEmission(amount: string): Promise<void> {
    const amountBigInt = BigInt(amount);

    this.emissionStatus.dailyEmitted = (BigInt(this.emissionStatus.dailyEmitted) + amountBigInt).toString();
    this.emissionStatus.weeklyEmitted = (BigInt(this.emissionStatus.weeklyEmitted) + amountBigInt).toString();
    this.emissionStatus.monthlyEmitted = (BigInt(this.emissionStatus.monthlyEmitted) + amountBigInt).toString();
    this.emissionStatus.totalEmitted = (BigInt(this.emissionStatus.totalEmitted) + amountBigInt).toString();
  }

  async canEmit(amount: string): Promise<boolean> {
    if (!this.config.emissionControlEnabled) {
      return true;
    }

    const amountBigInt = BigInt(amount);

    // Check all caps
    if (BigInt(this.emissionStatus.dailyEmitted) + amountBigInt > BigInt(this.emissionStatus.dailyCap)) {
      return false;
    }
    if (BigInt(this.emissionStatus.weeklyEmitted) + amountBigInt > BigInt(this.emissionStatus.weeklyCap)) {
      return false;
    }
    if (BigInt(this.emissionStatus.monthlyEmitted) + amountBigInt > BigInt(this.emissionStatus.monthlyCap)) {
      return false;
    }

    return true;
  }

  // --------------------------------------------------------------------------
  // Slashing
  // --------------------------------------------------------------------------

  async executeSlash(request: SlashRequest): Promise<SlashResult> {
    if (!this.config.slashingEnabled) {
      return {
        success: false,
        slashId: '',
        amount: '0',
        appealable: false,
        reason: 'Slashing is not enabled',
      };
    }

    const slashId = `slash_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    const now = new Date();

    const slashEvent: SlashEvent = {
      id: slashId,
      targetId: request.targetId,
      targetType: request.targetType,
      condition: request.condition,
      amount: request.amount,
      evidence: request.evidence,
      executedAt: now,
      executedBy: request.executedBy,
      appealable: true,
      appealDeadline: new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000),
      status: 'executed',
    };

    // Store slash
    if (!this.slashHistory.has(request.targetId)) {
      this.slashHistory.set(request.targetId, []);
    }
    this.slashHistory.get(request.targetId)!.push(slashEvent);

    // Set cooldown
    this.setCooldown(request.targetId, 'all', this.rateLimits.cooldowns.afterSlash);

    // Emit event
    this.emitEvent({
      type: 'slash_executed',
      category: 'anti_exploit',
      data: {
        slashId,
        targetId: request.targetId,
        condition: request.condition,
        amount: request.amount,
      },
      agentId: request.targetType === 'agent' ? request.targetId : undefined,
    });

    return {
      success: true,
      slashId,
      amount: request.amount,
      appealable: true,
      appealDeadline: slashEvent.appealDeadline,
    };
  }

  async appealSlash(slashId: string, _evidence: string[]): Promise<AppealResult> {
    // Find the slash
    for (const [_targetId, slashes] of this.slashHistory) {
      const slash = slashes.find(s => s.id === slashId);
      if (slash) {
        if (!slash.appealable) {
          return {
            success: false,
            slashId,
            status: 'rejected',
            reason: 'Slash is not appealable',
          };
        }

        if (slash.appealDeadline && new Date() > slash.appealDeadline) {
          return {
            success: false,
            slashId,
            status: 'rejected',
            reason: 'Appeal deadline has passed',
          };
        }

        // In production, this would go through arbitration
        // For now, mark as pending
        return {
          success: true,
          slashId,
          status: 'pending',
          reason: 'Appeal submitted for review',
        };
      }
    }

    return {
      success: false,
      slashId,
      status: 'rejected',
      reason: 'Slash not found',
    };
  }

  async getSlashHistory(targetId: string): Promise<SlashEvent[]> {
    return this.slashHistory.get(targetId) ?? [];
  }

  // --------------------------------------------------------------------------
  // Event Functions
  // --------------------------------------------------------------------------

  onEvent(callback: TokenomicsEventCallback): void {
    this.eventCallbacks.push(callback);
  }

  private emitEvent(event: Omit<TokenomicsEvent, 'id' | 'timestamp'>): void {
    const fullEvent: TokenomicsEvent = {
      id: `evt_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
      timestamp: new Date(),
      ...event,
    };

    for (const callback of this.eventCallbacks) {
      try {
        callback(fullEvent);
      } catch {
        // Ignore callback errors
      }
    }
  }

  // --------------------------------------------------------------------------
  // Internal: Reset functions (for periodic cleanup)
  // --------------------------------------------------------------------------

  /**
   * Reset daily emission counter (call at midnight)
   */
  resetDailyEmission(): void {
    this.emissionStatus.dailyEmitted = '0';
  }

  /**
   * Reset weekly emission counter (call weekly)
   */
  resetWeeklyEmission(): void {
    this.emissionStatus.weeklyEmitted = '0';
  }

  /**
   * Reset monthly emission counter (call monthly)
   */
  resetMonthlyEmission(): void {
    this.emissionStatus.monthlyEmitted = '0';
  }
}

// ============================================================================
// Internal Types
// ============================================================================

interface ClaimRecord {
  amount: string;
  timestamp: Date;
}

interface SybilReport {
  reporterId: string;
  evidence: string[];
  timestamp: Date;
}

// ============================================================================
// Factory Function
// ============================================================================

export function createAntiExploitManager(
  config?: Partial<AntiExploitConfig>,
  rateLimits?: Partial<TokenomicsRateLimitConfig>
): DefaultAntiExploitManager {
  return new DefaultAntiExploitManager(config, rateLimits);
}

export default DefaultAntiExploitManager;
